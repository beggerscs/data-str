Q.1
#include <iostream>
using namespace std;
int main() {
 int arr[5] = {1, 2, 3, 4, 5}; // [Farhan Shaikh - 38]: Array with elements
 cout << "[Farhan Shaikh - 38]: 1-Dimensional Array Output" << endl;
 // Accessing and printing elements
 for (int i = 0; i < 5; i++) {
 cout << "Element at index " << i << ": " << arr[i] << endl;
 }
 return 0;
}


Q.2
#include <iostream>
using namespace std;
int main() {
 int arr[2][3] = {{1, 2, 3}, {4, 5, 6}}; // [Farhan Shaikh - 38]: 2D Array with
 cout << "[Farhan Shaikh - 38]: 2-Dimensional Array Output" << endl;
 // Accessing and printing elements
 for (int i = 0; i < 2; i++) {
 for (int j = 0; j < 3; j++) {
 cout << "Element at [" << i << "][" << j << "]: " << arr[i][j] << endl;
 }
 }
 return 0;
}


Q.3
#include <iostream>
#include <stack>
using namespace std;
int main() {
 stack<int> stk; // [Farhan Shaikh - 38]: Stack
 // Pushing elements onto the stack
 stk.push(10);
 stk.push(20);
 stk.push(30);
 cout << "[Farhan Shaikh - 38]: Stack Output" << endl;
 // Accessing and printing elements
 while (!stk.empty()) {
 cout << "Top element: " << stk.top() << endl;
 stk.pop();
 }
 return 0;
}



Q.4
#include <iostream>
using namespace std;
#define MAX 5
class Queue {
 int front, rear, size;
 int arr[MAX];
public:
 Queue() : front(0), rear(-1), size(0) {}
 bool isFull() {
 return size == MAX;
 }
 bool isEmpty() {
 return size == 0;
 }
 void enqueue(int value) {
 if (isFull()) {
 cout << "[Farhan Shaikh - 38]: Queue is full" << endl;
 return;
 }
 rear = (rear + 1) % MAX;
 arr[rear] = value;
 size++;
 cout << " Enqueued " << value << " into the queue." << endl;
 }
 void dequeue() {
 if (isEmpty()) {
 cout << " Queue is empty" << endl;
 return;
 }
 cout << " Dequeued " << arr[front] << " from the queue." << endl;
 front = (front + 1) % MAX;
 size--;
 }
 void display() {
 if (isEmpty()) {
 cout << " Queue is empty." << endl;
 return;
 }
 cout << " Queue elements: ";
 for (int i = 0; i < size; i++)
 cout << arr[(front + i) % MAX] << " ";
 cout << endl;
 }
};
int main() {
 Queue q;
 q.enqueue(38);
 q.enqueue(58);
 q.enqueue(78);
 q.display();
 q.dequeue();
 q.display();
 return 0;
}


Q.5
#include <iostream>
using namespace std;

struct Node {    
int data;    
Node* next;
};

class LinkedList {    
Node* head;

public:    
LinkedList() : head(nullptr) {}    

void insert(int value) {        
Node* newNode = new Node();        
newNode->data = value;        
newNode->next = head;        
head = newNode;
cout << "[Saad Khan -46]: Inserted " << value << " into the list." << endl;
}    

void deleteNode(int value) {        
Node* temp = head;        
Node* prev = nullptr;        

// If the head node itself holds the value to be deleted        
if (temp != nullptr && temp->data == value) {            
head = temp->next;            
delete temp;
cout << "[Saad Khan -46]: Deleted " << value << " from the list." <<
endl;            
return;        
}        

// Search for the value to be deleted        
while (temp != nullptr && temp->data != value) {            
prev = temp;            
temp = temp->next;        
}        

// If value is not present        
if (temp == nullptr) {
    cout << "[Saad Khan -46]: Value not found in the list." << endl;
     return;        
}        

// Unlink the node and delete it        
prev->next = temp->next;        
delete temp;
cout << "[Saad Khan -46]: Deleted " << value << " from the list." << endl;
}    

void display() {        
Node* temp = head;
cout << "[Saad Khan -46]: List elements: ";
while (temp != nullptr) {           
cout << temp->data << " -> ";            
temp = temp->next;        
}        
cout << "NULL" << endl;    
}
};

int main() {    
LinkedList list;    
list.insert(38);    
list.insert(58);    
list.insert(78);    
list.display();    
list.deleteNode(58);    
list.display();    

return 0;
}
